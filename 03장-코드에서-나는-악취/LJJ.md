## 목차

- [3.1 기이한 이름](#31-기이한-이름)
- [3.2 중복코드](#32-중복코드)
- [3.3 긴 함수](#33-긴-함수)
- [3.4 긴 매개변수 목록](#34-긴-매개변수-목록)
- [3.5 전역 데이터](#35-전역-데이터)
- [3.6 가변 데이터](#36-가변-데이터)
- [3.7 뒤엉킨 변경](#37-뒤엉킨-변경)
- [3.8 산탄총 수술](#38-산탄총-수술)
- [3.9 기능 편애](#39-기능-편애)
- [3.10 데이터 뭉치](#310-데이터-뭉치)
- [3.11 기본형 집착](#311-기본형-집착)
- [3.12 반복되는 switch문](#312-반복되는-switch문)
- [3.13 반복문](#313-반복문)
- [3.14 성의 없는 요소](#314-성의-없는-요소)
- [3.15 추측성 일반화](#315-추측성-일반화)
- [3.16 임시 필드](#316-임시-필드)
- [3.17 메시지 체인](#317-메시지-체인)
- [3.18 중개자](#318-중개자)
- [3.19 내부자 거래](#319-내부자-거래)
- [3.20 거대한 클래스](#320-거대한-클래스)
- [3.21 서로 다른 인터페이스의 대안 클래스들](#321-서로-다른-인터페이스의-대안-클래스들)
- [3.22 데이터 클래스](#322-데이터-클래스)
- [3.23 상속 포기](#323-상속-포기)
- [3.24 주석](#324-주석)

## 3.1 기이한 이름

> 코드를 명료하게 표현하는데 가장 중요한 요소는 '이름'이다.

글쓴이는, 해당 책에서

- 함수 선언 바꾸기(6.5)
- 변수 이름 바꾸기(9.2)
- 필드 이름 바꾸기(6.7)
  와 같은 여러가지 이름 바꾸기 형태의 리팩터링을 제시한다.
  이름 바꾸는게 하나의 리팩터링으로 둘 만큼 중요하다는 것이다.

이름만 잘 지어도, 코드의 문맥을 파악하는데 큰 도움이 된다고 한다.

## 3.2 중복코드

똑같은 코드가 여러 곳에서 반복된다면 통합된 구조로 변경할 수 있다.

- 한 클래스에 딸린 두 메서드가 같을 때 : 함수 추출하기(6.1)
- 코드가 비슷하긴 하지만, 완전히 똑같지 않다면 : 문장 슬라이스하기(8.6)
- 같은 부모로부터 파생된 서브 클래스들에 코드가 중복된다면 : 메서드 올리기(12.1)

> 중복 코드를 수정할 때는 각각의 차이점이 없는지 주의 깊게 살펴봐야 한다.

## 3.3 긴 함수

> 오랜기간 사용되는 좋은 프로그램들의 함수는 짧다.
> 코드가 끝없이 위임하는 방식으로 작성되었기 때문이다.

위에서 이야기한 이름을 잘 정했을 때 문맥의 흐름을 파악할 수 있다고 했다.
함수를 짧게 만들고, 좋은 이름을 지어 놓으면, 문맥의 흐름을 파악하는데 도움이 된다.

함수의 이름은 동작 방식이 아닌 `의도`가 드러나도록 지어야 한다.

## 3.4 긴 매개변수 목록

매개변수 목록이 길어지면, 그 자체로 이해하기 어려울 수 있다.

- 데이터 구조에서 각각의 값을 뽑는게 아닌, 객체를 통째로 넘겨보자
- 항상 함께 전달되는 매개변수를 객체로 만들어서 넘겨자
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기로 없앤다.(이건 뭔지 잘 모르겠음)
- 여러 함수가 특정 매개변수로 사용된다면, 클래스로 묶는 것도 방법이다.

## 3.5 전역 데이터

전역 데이터(프론트의 전역 상태를 말하는게 아님)는 코드베이서 어디에서든 건드릴 수 있고, 누가 값을 바꿨는지 찾아낼 매커니즘이 없다.
그 이야기는 곳 버그로 이어진다.

> 변수 캡슐화 하기

다른 코드에서 변할 가능성이 있는 데이터를 발견할 때 마다, 캡슐화를 진행한다.

캡슐화는 다른 곳에서 사용될 가능성이 있는 데이터를 함수로 감싸는 것을 의미한다.
이런한 작업 하나만으로, 데이터를 수정하는 부분을 쉽게 찾을 수 있고, 접근을 통제할 수 있다.
더 나아가, 해당 함수를, 클래스, 모듈에 넣고, 그 안에서만 접근 가능하도록 만들면 좋다.

## 3.6 가변 데이터

데이터를 변경했을 때 예상치 못한 결과나 버그가 발생할 수 있다.
다른 곳에서 다른 기대값을 가지고 수정했을 때, 프로그램의 오류를 발견할 수 있다.

이러한 이유로, 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하는 경우에도, 복제본을 만들어서 관리후 반환하는걸 기본으로 삼고있다.

> 불변성

가변 데이터를 다룰순 있지만, 이 데이터를 다룰때는 최대한 접근범위를 줄여서 다뤄야한다.

## 3.7 뒤엉킨 변경

## 3.8 산탄총 수술

## 3.9 기능 편애

## 3.10 데이터 뭉치

## 3.11 기본형 집착

## 3.12 반복되는 switch문

## 3.13 반복문

## 3.14 성의 없는 요소

## 3.15 추측성 일반화

## 3.16 임시 필드

## 3.17 메시지 체인

## 3.18 중개자

## 3.19 내부자 거래

## 3.20 거대한 클래스

## 3.21 서로 다른 인터페이스의 대안 클래스들

## 3.22 데이터 클래스

## 3.23 상속 포기

## 3.24 주석
