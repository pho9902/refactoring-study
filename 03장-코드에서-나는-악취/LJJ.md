## 목차

- [3.1 기이한 이름](#31-기이한-이름)
- [3.2 중복코드](#32-중복코드)
- [3.3 긴 함수](#33-긴-함수)
- [3.4 긴 매개변수 목록](#34-긴-매개변수-목록)
- [3.5 전역 데이터](#35-전역-데이터)
- [3.6 가변 데이터](#36-가변-데이터)
- [3.7 뒤엉킨 변경](#37-뒤엉킨-변경)
- [3.8 산탄총 수술](#38-산탄총-수술)
- [3.9 기능 편애](#39-기능-편애)
- [3.10 데이터 뭉치](#310-데이터-뭉치)
- [3.11 기본형 집착](#311-기본형-집착)
- [3.12 반복되는 switch문](#312-반복되는-switch문)
- [3.13 반복문](#313-반복문)
- [3.14 성의 없는 요소](#314-성의-없는-요소)
- [3.15 추측성 일반화](#315-추측성-일반화)
- [3.16 임시 필드](#316-임시-필드)
- [3.17 메시지 체인](#317-메시지-체인)
- [3.18 중개자](#318-중개자)
- [3.19 내부자 거래](#319-내부자-거래)
- [3.20 거대한 클래스](#320-거대한-클래스)
- [3.21 서로 다른 인터페이스의 대안 클래스들](#321-서로-다른-인터페이스의-대안-클래스들)
- [3.22 데이터 클래스](#322-데이터-클래스)
- [3.23 상속 포기](#323-상속-포기)
- [3.24 주석](#324-주석)

## 3.1 기이한 이름

> 코드를 명료하게 표현하는데 가장 중요한 요소는 '이름'이다.

글쓴이는, 해당 책에서

- 함수 선언 바꾸기(6.5)
- 변수 이름 바꾸기(9.2)
- 필드 이름 바꾸기(6.7)
  와 같은 여러가지 이름 바꾸기 형태의 리팩터링을 제시한다.
  이름 바꾸는게 하나의 리팩터링으로 둘 만큼 중요하다는 것이다.

이름만 잘 지어도, 코드의 문맥을 파악하는데 큰 도움이 된다고 한다.

## 3.2 중복코드

똑같은 코드가 여러 곳에서 반복된다면 통합된 구조로 변경할 수 있다.

- 한 클래스에 딸린 두 메서드가 같을 때 : 함수 추출하기(6.1)
- 코드가 비슷하긴 하지만, 완전히 똑같지 않다면 : 문장 슬라이스하기(8.6)
- 같은 부모로부터 파생된 서브 클래스들에 코드가 중복된다면 : 메서드 올리기(12.1)

> 중복 코드를 수정할 때는 각각의 차이점이 없는지 주의 깊게 살펴봐야 한다.

## 3.3 긴 함수

> 오랜기간 사용되는 좋은 프로그램들의 함수는 짧다.
> 코드가 끝없이 위임하는 방식으로 작성되었기 때문이다.

위에서 이야기한 이름을 잘 정했을 때 문맥의 흐름을 파악할 수 있다고 했다.
함수를 짧게 만들고, 좋은 이름을 지어 놓으면, 문맥의 흐름을 파악하는데 도움이 된다.

함수의 이름은 동작 방식이 아닌 `의도`가 드러나도록 지어야 한다.

## 3.4 긴 매개변수 목록

매개변수 목록이 길어지면, 그 자체로 이해하기 어려울 수 있다.

- 데이터 구조에서 각각의 값을 뽑는게 아닌, 객체를 통째로 넘겨보자
- 항상 함께 전달되는 매개변수를 객체로 만들어서 넘겨자
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기로 없앤다.(이건 뭔지 잘 모르겠음)
- 여러 함수가 특정 매개변수로 사용된다면, 클래스로 묶는 것도 방법이다.

## 3.5 전역 데이터

전역 데이터(프론트의 전역 상태를 말하는게 아님)는 코드베이서 어디에서든 건드릴 수 있고, 누가 값을 바꿨는지 찾아낼 매커니즘이 없다.
그 이야기는 곳 버그로 이어진다.

> 변수 캡슐화 하기

다른 코드에서 변할 가능성이 있는 데이터를 발견할 때 마다, 캡슐화를 진행한다.

캡슐화는 다른 곳에서 사용될 가능성이 있는 데이터를 함수로 감싸는 것을 의미한다.
이런한 작업 하나만으로, 데이터를 수정하는 부분을 쉽게 찾을 수 있고, 접근을 통제할 수 있다.
더 나아가, 해당 함수를, 클래스, 모듈에 넣고, 그 안에서만 접근 가능하도록 만들면 좋다.

## 3.6 가변 데이터

데이터를 변경했을 때 예상치 못한 결과나 버그가 발생할 수 있다.
다른 곳에서 다른 기대값을 가지고 수정했을 때, 프로그램의 오류를 발견할 수 있다.

이러한 이유로, 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하는 경우에도, 복제본을 만들어서 관리후 반환하는걸 기본으로 삼고있다.

> 불변성

가변 데이터를 다룰순 있지만, 이 데이터를 다룰때는 최대한 접근범위를 줄여서 다뤄야한다.

## 3.7 뒤엉킨 변경

> 뒤엉킨 변경은 `단일 책임 원칙(SRP)`이 지켜지지 않을 때 나타난다.

하나의 로직을 처리하기 위해서, 다른 여러개의 로직을 다시 처리해야하는 상황이 발생할 수 있다.

## 3.8 산탄총 수술

> 산탄총 수술은 자잘하게 수정해야하는 부분이 많을 때 나타난다.

코드 전반에 수정해야하는 부분이 퍼져있다면, 수정하기 힘들다.

이럴 때, 함께 변경되는 대상을 묶어서 관리하면 편하다.

메서드, 클래스가 커지지만, 나중에 추출해서 리팩터링 하기 편하다.

## 3.9 기능 편애

> 기능편애는 본인이 속한 모듈이나, 클래스와의 상호작용보다, 외부와의 상호작용이 많을 때 발생한다.

함께 변경할 대상을 한데 모으는 것

예외가 있긴하지만, 그럴 때는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다.

## 3.10 데이터 뭉치

> 여러개의 데이터 항목이 함께 뭉처다니는 경우가 있다.

클래스로 만들어서 관리하자,
클래스로 옮기면, 종종 상당한 중복을 없애고, 향후 개발을 가속하는 유용한 클래스로 거듭난다.

## 3.11 기본형 집착

> 계산같은 작업을 할 때, 기본형을 그대로 사용하는 경우가 있다.

기본형을 객체로 바꾸기를 적용하기,
조건부 로직을 다형성으로 바꾸기,
클래스 추출하기

## 3.12 반복되는 switch문

switch문을 클래스를 활용한 `다형성` 효율적으로 관리할 수 있다.

## 3.13 반복문

반복문을 `파이프라인`으로 바꾸면 효율적으로 반복문을 사용할 수 있다.

## 3.14 성의 없는 요소

리팩터링을 하다 보면, 처음에는 풍부했던 클래스도 하나 둘 씩 쪼개지면서 메서드 하나만 남는 모양이 될 수 있다. 이런식으로 리팩터링을 통해서 그 역할이 사라저버린 기능들은 보내주자.

## 3.15 추측성 일반화

미래에 대한 예측으로 "나중에는 사용할거야" 라는 추측성 일반화를 통해서 코드를 남겨둔 후,

나중에 사용되면 괜찮지만, 사용되지 않는다면 쓸모없는 낭비일 뿐이다.

- 계층 합치기
- 함수/클래스 인라인하기
- 함수 선언 바꾸기
  로 사용되지않는 기능들을 하나씩 지워보자

## 3.16 임시 필드

임시필드 실제 기능과 동떨어져 있는 값들로, 해당 값을 적절히 코드에 넣어야 한다.

## 3.17 메시지 체인

> 메시지 체인은, 클라이언트가 하나의 객체를 활용해 새로운 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식이다.

- 꼬리에 꼬리가 이어지는 변수들이 줄줄이 나열되어 있는 코드는 `위임 숨기기`로 처리할 수 있다.

최종 결과 객체가 어떻게 쓰이는지 살펴보고
함수 추출하기나, 함수 옮기기를 통해서 체인을 숨길 수 있는 지 살펴봐야 한다

```javascript
//부서장 의 이름을 찾기위해 aPerson -> department -> manger 를 타고 들어가야한다.
managerName = aPerson.department.manager.name;

managerName = aPerson.department.managerName; //관리가 객체(manger) 의 존재를 숨김
managerName = aPerson.manager.name; //부서 객체(department)의 존재를 숨김
managerName = aPerson.managerName; //부서 객체와 관리자 객체 모두의 존재를 숨김

//해당 변수를 함수로 옮겨서 체인의 존재를 감출 수 있다.
```

## 3.18 중개자

- 객체의 대표적인 기능으로는 외부로부터 세부사항을 숨겨주는 `캡슐화`가 있다.

예시로

- 팀장에게 미팅을 요청한다 -> 팀장은 자신의 일정을 확인한 후 답을 준다

이 과정에서 팀장이 일정을 정리하는 행위를 우리는 알 필요가 없다.

하지만, 지나치게 많은 정보를 숨기고 있다면 문제가 될 수 있다.
만약 클래스가 제공하는 메서드 중 절반이 다른 클래스 구현을 위임하고 있다면?
`중개자 제거하기` 를 통해서 실제로 일하는 객체와 직접 소통하도록 해야한다.

## 3.19 내부자 거래

모듈간 데이터의 이동을 최소한으로 줄이고, 투명하게 처리해야한다.

- 여러모듈이 같은 관심사를 공유한다면, 공통 부분을 정식으로 처리하는 제 3의 모듈을 만들어보자
- 부모 클래스가 공개하고 싶은것 이상으로 원한다면, 서브클래스를 위임으로 바꿔야한다.

## 3.20 거대한 클래스

하나의 클래스에서 너무 많은 일은 하다보면, 필드의 수가 상당히 늘어난다.

- 같은 접두어나 접미어를 가진 필드들을 함께 추출하기
- 사용하지 않는 필드도 제거
- 메서드 안에서 공통으로 사용되는 로직을 분리해서 관리하기

## 3.21 서로 다른 인터페이스의 대안 클래스들

- 클래스를 사용할 때 장점은 필요에 따라서 다른 클래스로 교체가 가능하다는 저밍다.

교체 하려면 같은 인터페이스를 가지고 있어야 하는데, 함수 선언 바꾸기, 함수 옮기기를 이용해 인터페이스가 같아질 때 필요한 동작을 클래스에 밀어 넣는다.

## 3.22 데이터 클래스

> 데이터 클래스는 데이터 필드와 게터,세터로만 이루어진 클래스를 의미한다.

동일한 데이터를 다루는 게터,세터를 한 곳에 몰아 두어야 한다.

불변 데이터로부터 나오는 정보는 굳이 갭슐화 할 필요없다. 그냥 public으로 해둬도 괜찮다.

## 3.23 상속 포기

상속 포기는 냄새가 심하지 않음 -> 실무에서 그냥 두는 경우가 많다.

부모의 인터페이스를 따르고 싶지 않을 때는 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기를 이용해 상속 메커니즘에서 벗어나는 것도 방법이다.

## 3.24 주석

> 주석을 남겨야 겠다는 생각이 들면, 가장 먼저 주석이 필요없는 코드로 리팩터링 해본다.

함수 추출하기, 함수 선언 바꾸기, 어서션 추가하기와 같이 주석을 달지 않고, 개발자가 코드를 이해하는데 도움이 될만한
방향으로 코드를 리팩터링 해보자
