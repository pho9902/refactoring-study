## 목차

- [2.1 리펙터링 정의](#21-리펙터링-정의)
- [2.2 두 개의 모자](#22-두-개의-모자)
- [2.3 리팩터링하는 이유](#23-리팩터링하는-이유)
- [2.4 언제 리팩터링해야 할까?](#24-언제-리팩터링해야-할까)
- [2.5 리팩터링 시 고려할 문제](#25-리팩터링-시-고려할-문제)
- [2.6 리팩터링, 아키텍처, 에그니(YAGNI)](#26-리팩터링-아키텍처-에그니yagni)
- [2.7 리팩터링과 소프트웨어 개발 프로세스](#27-리팩터링과-소프트웨어-개발-프로세스)
- [2.8 리팩터링과 성능](#28-리팩터링과-성능)
- [2.9 리팩터링의 유래](#29-리팩터링의-유래)
- [2.10 리팩터링 자동화](#210-리팩터링-자동화)

## 2.1 리펙터링 정의

- 리팩터링은 코드를 정리하는 모든 작업을 말한다.
- 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고
- 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일
  > 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않더라도 언제든 멈출 수 있다.

```
지금까지 내가 리팩터링이라고 부르던 친구들은 사실 리팩터링이 아니었던 것 같다...리팩터링을 진행하면 항상 코드가 깨져서 고생하는데, 여기서는 그걸 리팩터링이라고 부르지 않는다.
```

코드 베이스를 정리하거나, 구조를 바꾸는 모든 작업을 `재구성` 이라는 포괄적인 의미로 표현한다.

| 이름       | 목적                                                                            |
| ---------- | ------------------------------------------------------------------------------- |
| 리팩터링   | 기능은 유지하고, 코드를 이해하고 수정하기 쉽게 만드는 것이 목적                 |
| 성능최적화 | 속도 개선에 초점을 둔 코드 변경, 이 과정에서 코드가 오히려 더 복잡해질 수 있다. |

## 2.2 두 개의 모자

`기능추가`모자를 썼다면, 기능추가만하고, 수정을 하지 않는다.
`리팩터링`모자를 썼다면, 기능추가는 하지 않고, 코드를 재구성하는 일에만 집중한다.

글쓴이는 `기능추가`중간에 `구조개선`이 필요하다고 느끼면, `리팩터링`모자를 잠깐 써서, 코드의 구조를 바꾸고, 다시 `기능추가`모자로 돌아와 작업을 한다고 한다.

## 2.3 리팩터링하는 이유

> 리팩터링하면 소프트웨어 설계가 좋아진다.

중복 코드 제거는 설계 개선 작업의 중요한 축을 차지한다.
코드량을 줄인다고 해서 시스템이 빨라지는 것은 아니지만, 수정하는데 드는 노력은 크게 달라질 수 있다.
또한, 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다.

> 리팩터링하면 소프트웨어 이해하기 쉬워진다.

미래의 내가, 혹은 내가 아닌 다른사람이 코드를 확인할 때, 코드를 쉽게 이해할 수 있다.

> 버그를 찾기 쉽다.

> 프로그래밍 속도를 높일 수 있다.

처음 리팩터링을 진행할때는 오히려 시간이 더 걸린다고 생각할 수 있지만, 지속적인 기능 추가로 인해서 변경점이 발생할 때, 잘 짜여진 설계를 바탕으로한 구조는 쉽게 기능추가가 가능하기 때문에, 결과적으로 프로그래밍 속도가 증간한다.

## 2.4 언제 리팩터링해야 할까?

## 2.5 리팩터링 시 고려할 문제

## 2.6 리팩터링, 아키텍처, 에그니(YAGNI)

## 2.7 리팩터링과 소프트웨어 개발 프로세스

## 2.8 리팩터링과 성능

## 2.9 리팩터링의 유래

## 2.10 리팩터링 자동화

## 2.11 더 알고 싶다면
